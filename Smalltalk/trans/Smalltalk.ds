module trans/Smalltalk

imports 
src-gen/ds-signatures/Smalltalk-sig
src-gen/ds-signatures/Base-sig
src-gen/ds-signatures/Common-sig

signature
  sorts
  	V
  	O
  	E
  	Chain
  constructors
    NumV: Int -> V
    BoolV: Bool -> V
    OP: String -> O    
    OP: String * String -> O    
    ExpRest: O * V -> E
    ExpI: Int * List(BinaryMessage) -> V
    ExpB: Bool * List(BinaryMessage) -> V
  arrows
    Prog -init-> V
  	Expression --> V
  	Literal --> V
  	Operand --> V
  	BinaryMessage --> E
  	MessageChain --> MessageChain
  	BinaryMessageOperand --> V
  	BinaryMessageSelector --> O
  	BinaryMessageChain --> List(BinaryMessage)
  	Statement --> V
  	ConstantReference --> V
  	V --> V
  variables
  	v : V
  	o : O
  native operators
    parseI: String -> Int
    binOpI: Int * Int * String -> Int
    binOpB: Bool * Bool * String -> Bool
  sort aliases
    Env = Map(String, V)
    Heap = Map(Int, V)
  components
    H : Heap
    E : Env
    
rules
	
	Program(Temp(e)) -init-> v
	  where
	    E {} |- e :: H {} --> v :: H _.
//	    
	    //    
	SingletonExpression(e1) --> e1.
	
	Expression(e1, e2, cascaded) --> e4
	where 
		e1 --> NumV(i1);
		e2 --> BinaryMessage2(ExpRest(OP(op), NumV(i2)), messageChain);
		binOpI(i1, i2, op) => i3;
		ExpI(i3, messageChain) --> e4.
		
	ExpI(i3, [binMessage1 | rest]) --> NumV(i1)
		where
			binMessage1 --> ExpRest(OP(op), NumV(i2));
			binOpI(i3, i2, op) => i4;
			ExpI(i4, rest) --> NumV(i1).
			
	ExpI(e3, []) --> NumV(e3).
	
	Expression(e1, e2, cascaded) --> e4
	where 
		e1 --> BoolV(b1);
		e2 --> BinaryMessage2(ExpRest(OP(op), BoolV(b2)), messageChain);
		binOpB(b1, b2, op) => b3;
		ExpB(b3, messageChain) --> e4.
		
	ExpB(b1, [binMessage1 | rest]) --> b
		where
			binMessage1 --> ExpRest(OP(op), BoolV(b2));
			binOpB(b1, b2, op) => b3;
			ExpB(b3, rest) --> b
			
	ExpB(e3, []) --> BoolV(e3).
		
	Literal2(e1) --> e1.
		
	IntegerLiteral(s) --> NumV(parseI(s)).
	ConstantReference4(bool) --> bool.
	
	True() --> BoolV(true).
	False() --> BoolV(false).
	
	BinaryMessage1(selector, operand) --> ExpRest(selector, operand).
		
	UnarySelector(op) --> OP(op).
	BinarySelector(op1, op2) --> OP(op1, op2).
			
	BinaryMessage2(binMessage, messageChain) --> BinaryMessage2(binMessage, messageChain).
	
	BinaryMessageOperand(literal, unarychain) --> literal.
	
	BinaryMessageChain(list) --> list.
	
	NestedExpression(statement) --> statement.
	Statement(assignmentOperations, expression) --> expression.
//	
//	Plus(NumV(i1), NumV(i2)) --> NumV(addI(i1, i2)).
//	Minus(NumV(i1), NumV(i2)) --> NumV(subI(i1, i2)).
//	Times(NumV(i1), NumV(i2)) --> NumV(mulI(i1, i2)).	
//	
//   Let(x, v1, e2) --> v2
//  where
//    E bindVar(x, v1) |- e2 --> v2.
//
//  Var(x) --> readVar(x).
//  
//  Box(v) --> BoxV(allocate(v)).
//
//  Unbox(BoxV(addr)) --> read(addr).
//
//  Setbox(BoxV(addr), v) --> write(addr,v).
//  
//  E |- Fun(x, e) --> ClosV(x, e, E).
//
//  App(ClosV(x, e, E), v1) --> v2
//  where
//    E  |- bindVar(x, v1) --> E';
//    E' |- e --> v2.
//    
    