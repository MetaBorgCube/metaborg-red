module trans/dynamics/Smalltalk

imports 
src-gen/ds-signatures/Smalltalk-sig
src-gen/ds-signatures/Base-sig
trans/runtime/values
trans/runtime/store
trans/environment/environment

signature
  constructors
    NumV: Int -> V
    BoolV: Bool -> V
	IntIntO: String -> O
    ExpRest: BinaryMessageSelector * V -> E
    ExpI: V * List(BinaryMessage) -> V
  arrows
    Prog -init-> V
    ExecutableCodeRest --> V
    FinalStatement --> V
    
    StatementExecutor(List(Statement)) --> Env
    DotRemover(List(DottedStatement)) --> List(Statement)
    Statement --> V
    AssignmentOperation --> E
    
  	Expression --> V
  	
  	Literal --> V
  	Operand --> V
  	BinaryMessage --> E
  	MessageChain -->  List(BinaryMessage)
  	BinaryMessageOperand --> V
  	BinaryMessageSelector --> O
  	Statement --> V
  	ConstantReference --> V
  	ExecutableCodeRest --> V
  	V --> V
  native operators
    parseI: String -> Int
    binOpII: Int * Int * String -> Int
    binOpIB: Int * Int * String -> Bool
    binOpBB: Bool * Bool * String -> Bool
  sort aliases
    Env = Map(String, V)
    Heap = Map(Int, V)

  components
    H : Heap
    E : Env
    
rules
	
//	Program(Temp(e)) -init-> v
//	  where
//	    E {} |- e :: H {} --> v :: H _.
	       
	
	Program(ExecutableCode(rest)) -init-> v
		where
			E {} |- rest :: H {} --> v :: H _.

	ExecutableCodeRest(statements, finalstmt) --> v
		where
			StatementExecutor(DotRemover(statements)) --> E1;
			E1 |- finalstmt --> v.



	DotRemover([]) --> [].
	DotRemover([DottedStatement(head) | tail]) --> [head | rest]
	where
		DotRemover(tail) --> rest.
			
	E |- StatementExecutor([]) --> E.
	StatementExecutor([Statement(assignments, expression) | tail]) --> E2
	where
		expression --> v;
		bindVar(assignments, v) --> E1;
		E1 |- StatementExecutor(tail) --> E2.
			
	    
	FinalStatement(Statement(_, expression)) --> v
		where
			expression --> v.


	SingletonExpression(e1) --> e1.	
	
	Expression(e1, e2, cascaded) --> e3
	where 
		e2 --> [binMes | messageChain];
		ExpI(e1, e2) --> e3.
		
	ExpI(e1, [binMessage1 | rest]) --> e4
		where
			binMessage1 --> ExpRest(ops, e2);
		case ops of {
			IntInt(op1) => 
				e1 --> NumV(i1);
				e2 --> NumV(i2);
				binOpII(i1, i2, op1) => i3;
				ExpI(NumV(i3), rest) --> e4
			IntBool(op2) =>				
				e1 --> NumV(i1);
				e2 --> NumV(i2);
				binOpIB(i1, i2, op2) => b1;
				ExpI(BoolV(b1), rest) --> e4
			BoolBool(op2) =>				
				e1 --> BoolV(b1);
				e2 --> BoolV(b2);
				binOpBB(b1, b2, op2) => b3;
				ExpI(BoolV(b3), rest) --> e4
//			ObjectBool(op2) =>	
//				case of e1 {
//					NumV(i1) =>
//						case of e2 {
//							NumV(i1) => true --> b1
//							NumV(i2) => false --> b1
//						}
//					BoolV(i1) =>
//						case of e2 {
//							BoolV(i1) => true --> b1
//							BoolV(i2) => false --> b1
//						}
//				}			
//				e1 --> NumV(i1);
//				e2 --> NumV(i2);
//				binOpOB(i1, i2, op2) => b1;
//				ExpI(BoolV(b1), rest) --> e4
		}
			
	ExpI(e3, []) --> e3.
	
		
	Literal(e1) --> e1.
		
	IntegerLiteral(s) --> NumV(parseI(s)).
	ConstantReference(bool) --> bool
		where bool --> BoolV(b).
	
	True() --> BoolV(true).
	False() --> BoolV(false).
	
	NumV(a) --> NumV(a).
	BoolV(b) --> BoolV(b).
	
	BinaryMessage(selector, operand) --> ExpRest(selector, operand).

			
//	BinaryMessage(binMessage, messageChain) --> [binMessage | messageChain].
	
	BinaryMessageOperand(literal, unarychain) --> literal.
	
	BinaryMessageChain(list) --> list.
	
//	NestedExpression(statement) --> statement.
	Statement(assignmentOperations, expression) --> expression.

	BinaryMessageOperand(literal, chain) --> literal. 
    