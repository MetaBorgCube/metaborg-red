module trans/runtime/store

imports
  trans/runtime/values
  
  trans/dynamics/Objects

signature
  constructors
  	RefV: Int -> V

  sort aliases
    Scope = Map(String, Map(String, V))
    Heap = Map(V, Object)

  components
    H : Heap
    S : Scope

  arrows
    read(V) --> Object
    allocate(Object) --> V
    write(V, Object) --> Object

	bindToGlobalMap(List(String), V) --> V
	bindToGlobal(String, V) --> V

    bindVarMap(List(String), V) --> V
    bindVar(String, V) --> V
    bindVarToObject(String, V) --> V
    bindVarToClass(V, String, V) --> V
    bindVarToGlobal(String, V) --> V
    
    readVar(String) --> V
    readVarFromObject(String) --> V
    readVarFromClass(V, String) --> V
    readVarFromGlobal(String) --> V
   
   native operators
   	errorV: String -> V

rules

  read(addr) :: S, H --> H[addr].

  allocate(o) :: S, H --> addr :: S, H H1
  where
    fresh => addrint;
    RefV(addrint) => addr;
    write(addr, o) --> _ :: S, H1.

  write(addr, o) :: S, H --> o :: S, H {addr |--> o, H}.
  
  bindToGlobalMap([], v) --> v.
  bindToGlobalMap([id | tail], v) :: S, H --> v :: S S2, H H2
  where
  	bindToGlobal(id, v) :: S, H --> _ :: S1, H1;
  	bindToGlobalMap(tail, v) :: S1, H1 --> E :: S2, H2.
  
  bindVarMap([], v) --> v.
  bindVarMap([id | tail], v) :: S, H --> v :: S S2, H H2
  where
  	bindVar(id, v) :: S, H --> _ :: S1, H1;
  	bindVarMap(tail, v) :: S1, H1 --> E :: S2, H2.

  readVar(id) :: S, H --> v
  where
  	case S["local"?] of {
  		true =>
  			S["local"] => localScope;
  			case localScope[id?] of {
  				true =>
  					localScope[id] => v
  				otherwise =>
  					readVarFromObject(id) --> v
  			}
  		otherwise =>
  			readVarFromObject(id) --> v
  	}
  	
  readVarFromObject(id) :: S, H --> v
  where
  	case S["refs"?] of {
  		true =>
  			S["refs"] => objectReferences;
  			case objectReferences["object"?] of {
  				true =>
  					case objectReferences["object"] of {
				  		RefV(addr) =>
				  			case read(RefV(addr)) of {
				  				Object(classRef, attributes, methods) =>
				  					case attributes[id?] of {
				  						true =>
				  							attributes[id] => v
				  						otherwise =>
				  							readVarFromClass(classRef, id) --> v
				  					}
				  			}
				  	}
  				otherwise =>
  					errorV("variable not found: refs->object not found") => v
  			}
  		otherwise =>
  			readVarFromGlobal(id) --> v
  	}
  	
  	// reached Object
  	readVarFromClass(classRef, id) :: S, H --> v
  	where
  		case read(classRef) of {
  			Class(parentRef, Object(classRef, _, _), attributes, _) =>
  				parentRef == classRef;
  				case attributes[id?] of {
  					true =>
  						attributes[id] => v
  					otherwise =>
  						readVarFromGlobal(id) --> v
  				}
  		}
  	
  	// traversing class tree
  	readVarFromClass(classRef, id) :: S, H --> v
  	where
  		case read(classRef) of {
  			Class(parentRef, Object(classRef, _, _), attributes, _) =>
  				parentRef != classRef;
  				case attributes[id?] of {
  					true =>
  						attributes[id] => v
  					otherwise =>
  						readVarFromClass(parentRef, id) --> v
  				}
  		}
  		
  	readVarFromGlobal(id) :: S, H --> v
  	where
  		S["global"] => globalScope;
  		case globalScope[id?] of {
  			true =>
  				globalScope[id] => v
  			otherwise =>
  				errorV("variable not found to read: refs->object->..class->global not found") => v
  		}
  		
  		
  bindToGlobal(id, value) :: S, H --> value :: S S1, H
  where
  	case S["global"?] of {
  		true =>
  			S["global"] => localScope
  		otherwise =>
  			{} : Map(String, V) => localScope
  	};
  	{id |--> value, localScope} => localScope;
  	{"global" |--> localScope, S} => S1.
  		
  		
  bindVar(id, value) :: S, H --> value :: S S1, H H1
  where
  	case S["local"?] of {
  		true =>
  			S["local"] => localScope;
  			case localScope[id?] of {
  				true =>
  					{id |--> value, localScope} => localScope;
  					{"local" |--> localScope} => S1;
  					H => H1
  				otherwise =>
  					bindVarToObject(id, value) --> _ :: S S1, H H1
  			}
  		otherwise =>
  			bindVarToObject(id, value) --> _ :: S S1, H H1
  	}
  	
  bindVarToObject(id, value) :: S, H --> value :: S S1, H H1
  where
  	case S["refs"?] of {
  		true =>
  			S["refs"] => objectReferences;
  			case objectReferences["object"?] of {
  				true =>
  					case objectReferences["object"] of {
				  		RefV(addr) =>
				  			case read(RefV(addr)) of {
				  				Object(classRef, attributes, methods) =>
				  					case attributes[id?] of {
				  						true =>
				  							{id |--> value, attributes} => newAttributes;
				  							write(RefV(addr), Object(classRef, newAttributes, methods)) :: S, H --> _ :: S S1, H H1
				  						otherwise =>
				  							bindVarToClass(classRef, id, value) --> v :: S S1, H H1
				  					}
				  			}
				  	}
  				otherwise =>
  					errorV("variable not found: refs->object not found") => v;
  					H => H1;
  					S => S1
  			}
  		otherwise =>
  			bindVarToGlobal(id, value) :: S, H --> _ :: S S1, H H1
  	}
  	
  	// reached Object
  	bindVarToClass(classRef, id, value) :: S, H --> value :: S S1, H H1
  	where
  		case read(classRef) of {
  			Class(parentRef, Object(classRef, objAttributes, objMethods), attributes, classMethods) =>
  				parentRef == classRef;
  				case attributes[id?] of {
  					true =>
  						{id |--> value, attributes} => newAttributes;
				  		write(classRef, Class(parentRef, Object(classRef, objAttributes, objMethods), newAttributes, classMethods)) :: S, H --> _ :: S S1, H H1
  					otherwise =>
  						bindVarToGlobal(id, value) :: S, H --> _ :: S S1, H, H1
  				}
  		}
  	
  	// traversing class tree
  	bindVarToClass(classRef, id, value) :: S, H --> value :: S S1, H H1
  	where
  		case read(classRef) of {
  			Class(parentRef, Object(classRef, objAttributes, objMethods), attributes, classMethods) =>
  				parentRef != classRef;
  				case attributes[id?] of {
  					true =>
  						{id |--> value, attributes} => newAttributes;
				  		write(classRef, Class(parentRef, Object(classRef, objAttributes, objMethods), newAttributes, classMethods)) :: S, H --> _ :: S S1, H H1
  					otherwise =>
  						bindVarToClass(parentRef, id, value) :: S, H --> _ :: S S1, H H1
  				}
  		}
  		
  	bindVarToGlobal(id, value) :: S, H --> value :: S S1, H
  	where
  		S["global"] => globalScope;
  		case globalScope[id?] of {
  			true =>
  				{id |--> value, globalScope} => newScope;
  				{"global" |--> newScope, S} => S1
  			otherwise =>
  				errorV("variable not found to write: refs->object->..class->global not found") => _;
  				S => S1
  		}
  		
  		