definition

module completion/Base-completion-insertions
imports Base

exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    [A-Za-z0-9\_]                  -> WATERTOKENSTART     {recover, avoid}
    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN          
    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover, avoid}
    "*"                            -> WATERTOKENSTAR      {recover, avoid}
    WATERTOKEN                     -> WATER               
    WATERTOKENSEPARATOR            -> WATER               
    WATERTOKENSTAR                 -> WATER               
                                   -> WATEREOF            

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules                                                                         
    "\""                                                        -> INSERTOPENQUOTE                              {recover}
    INSERTOPENQUOTE CommentCharacter* "\n"                      -> Comment                                      {cons("INSERTEND")}
    INSERTOPENQUOTE CommentCharacter* WATEREOF                  -> Comment                                      {cons("INSERTEND")}
    "\""                                                        -> INSERTSTART                                  {recover}
    INSERTSTART CommentCharacter* WATEREOF                      -> Comment                                      {cons("INSERTEND")}
                                                                -> "_"                                          {recover, cons("INSERTION")}
                                                                -> "~"                                          {recover, cons("INSERTION")}
                                                                -> "!"                                          {recover, cons("INSERTION")}
                                                                -> "@"                                          {recover, cons("INSERTION")}
                                                                -> "%"                                          {recover, cons("INSERTION")}
                                                                -> "&"                                          {recover, cons("INSERTION")}
                                                                -> "*"                                          {recover, cons("INSERTION")}
                                                                -> "+"                                          {recover, cons("INSERTION")}
                                                                -> "="                                          {recover, cons("INSERTION")}
                                                                -> "\\"                                         {recover, cons("INSERTION")}
                                                                -> "<"                                          {recover, cons("INSERTION")}
                                                                -> ">"                                          {recover, cons("INSERTION")}
                                                                -> ","                                          {recover, cons("INSERTION")}
                                                                -> "?"                                          {recover, cons("INSERTION")}
                                                                -> "/"                                          {recover, cons("INSERTION")}
                                                                -> "r"                                          {recover, cons("INSERTION")}
                                                                -> "s"                                          {recover, cons("INSERTION")}
                                                                -> "-"                                          {recover, cons("INSERTION")}
                                                                -> "$"                                          {recover, cons("INSERTION")}
    "'"                                                         -> INSERTOPENQUOTE                              {recover}
    INSERTOPENQUOTE ( StringLiteralCharacter | "''" )* "\n"     -> StringLiteral                                {cons("INSERTEND")}
    INSERTOPENQUOTE ( StringLiteralCharacter | "''" )* WATEREOF -> StringLiteral                                {cons("INSERTEND")}
                                                                -> "''"                                         {recover, cons("INSERTION")}
                                                                -> "'"                                          {recover, cons("INSERTION")}
                                                                -> "nil"                                        {recover, cons("INSERTION")}
                                                                -> "false"                                      {recover, cons("INSERTION")}
                                                                -> "true"                                       {recover, cons("INSERTION")}
                                                                -> "self"                                       {recover, cons("INSERTION")}
                                                                -> "super"                                      {recover, cons("INSERTION")}
                                                                -> "thisContext"                                {recover, cons("INSERTION")}
                                                                -> ":"                                          {recover, cons("INSERTION")}
                                                                -> "#"                                          {recover, cons("INSERTION")}
                                                                -> "#["                                         {recover, cons("INSERTION")}
                                                                -> "]"                                          {recover, cons("INSERTION")}
                                                                -> ")"                                          {recover, cons("INSERTION")}
                                                                -> ":="                                         {recover, cons("INSERTION")}
                                                                -> "^"                                          {recover, cons("INSERTION")}
                                                                -> "|"                                          {recover, cons("INSERTION")}
                                                                -> "."                                          {recover, cons("INSERTION")}
                                                                -> "$Prog"                                      {recover, cons("INSERTION")}
                                                                -> "$Start"                                     {recover, cons("INSERTION")}
                                                                -> "$PsuedoVariableReference"                   {recover, cons("INSERTION")}
                                                                -> "$Identifier"                                {recover, cons("INSERTION")}
                                                                -> "$BinarySelectorChar"                        {recover, cons("INSERTION")}
                                                                -> "$KeywordMessageSelector"                    {recover, cons("INSERTION")}
                                                                -> "$SymbolInArrayLiteral"                      {recover, cons("INSERTION")}
                                                                -> "$ByteArrayLiteral"                          {recover, cons("INSERTION")}
                                                                -> "$UnsignedIntegerLiteral"                    {recover, cons("INSERTION")}
                                                                -> "$FormalBlockArgumentDeclaration"            {recover, cons("INSERTION")}
                                                                -> "$FormalBlockArgumentDeclarationList"        {recover, cons("INSERTION")}
                                                                -> "$FormalBlockArgumentDeclarationListWithSep" {recover, cons("INSERTION")}
                                                                -> "$ConstantReference"                         {recover, cons("INSERTION")}
                                                                -> "$IntegerLiteral"                            {recover, cons("INSERTION")}
                                                                -> "$ScaledDecimalLiteral"                      {recover, cons("INSERTION")}
                                                                -> "$FloatingPointLiteral"                      {recover, cons("INSERTION")}
                                                                -> "$CharacterLiteral"                          {recover, cons("INSERTION")}
                                                                -> "$StringLiteral"                             {recover, cons("INSERTION")}
                                                                -> "$SymbolLiteral"                             {recover, cons("INSERTION")}
                                                                -> "$Reference"                                 {recover, cons("INSERTION")}
                                                                -> "$UnaryMessage"                              {recover, cons("INSERTION")}
                                                                -> "$UnaryMessageChain"                         {recover, cons("INSERTION")}
                                                                -> "$AssignmentOperation"                       {recover, cons("INSERTION")}
                                                                -> "$MethodReturnOperator"                      {recover, cons("INSERTION")}
                                                                -> "$LocalVariableDeclarationList"              {recover, cons("INSERTION")}
                                                                -> "$Dot"                                       {recover, cons("INSERTION")}
                                                                -> "$UnaryMessageSelector"                      {recover, cons("INSERTION")}
                                                                -> "$BinaryMessageSelector"                     {recover, cons("INSERTION")}
                                                                -> "$Keyword"                                   {recover, cons("INSERTION")}
                                                                -> "$BindableIdentifier"                        {recover, cons("INSERTION")}
                                                                -> "$KeywordMethodHeaderSegment"                {recover, cons("INSERTION")}
                                                                -> "$UnaryMethodHeader"                         {recover, cons("INSERTION")}
                                                                -> "$BinaryMethodHeader"                        {recover, cons("INSERTION")}
                                                                -> "$KeywordMethodHeader"                       {recover, cons("INSERTION")}
                                                                -> "$MethodDeclaration"                         {recover, cons("INSERTION")}
                                                                -> "$MethodHeader"                              {recover, cons("INSERTION")}

  syntax
    %% Kernel syntax insertion recovery rules   

  )

  lexical syntax
     -> COMPLETION-INSERTION 

module Base
exports
  lexical syntax
    ~[]                                                                                            -> Character              
    [\ \t\n\r]                                                                                     -> WhitespaceCharacter    
    [0-9]                                                                                          -> DecimalDigit           
    [a-zA-Z]                                                                                       -> Letter                 
    ~[\"]                                                                                          -> CommentCharacter       
    [\\\"]                                                                                         -> CommentCharacter       
    "\"" CommentCharacter* "\""                                                                    -> Comment                
    ( WhitespaceCharacter | Comment )+                                                             -> Whitespace             
    WhitespaceCharacter                                                                            -> LAYOUT                 
    Comment                                                                                        -> LAYOUT                 
    DecimalDigit | Letter                                                                          -> LetterOrDigit          
    Letter | "_" ( DecimalDigit | Letter | "_" )+                                                  -> Identifier             
    "~" | "!" | "@" | "%" | "&" | "*" | "-" | "+" | "=" | "|" | "\\" | "<" | ">" | "," | "?" | "/" -> BinarySelectorChar     
    "-"? UnsignedIntegerLiteral                                                                    -> IntegerLiteral         
    DecimalIntegerLiteral | ( Radix "r" BaseNIntegerLiteral )                                      -> UnsignedIntegerLiteral 
    DecimalDigit+                                                                                  -> DecimalIntegerLiteral  
    DecimalIntegerLiteral                                                                          -> Radix                  
    LetterOrDigit+                                                                                 -> BaseNIntegerLiteral    
    "-"? DecimalIntegerLiteral ( "." DecimalIntegerLiteral )? "s" DecimalIntegerLiteral?           -> ScaledDecimalLiteral   
    "-"? DecimalIntegerLiteral ( "." DecimalIntegerLiteral Exponent? ) | Exponent                  -> FloatingPointLiteral   
    "e" | "d" | "q" ( "-"? DecimalIntegerLiteral )?                                                -> Exponent               
    "$" Character                                                                                  -> CharacterLiteral       
    "'" ( StringLiteralCharacter | "''" )* "'"                                                     -> StringLiteral          
    ~[\']                                                                                          -> StringLiteralCharacter 

  lexical restrictions
    CommentCharacter -/- [\"]
    DecimalDigit -/- [0-9]
    Identifier -/- [a-zA-Z0-9\_]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\"]

module Smalltalk
imports Base

exports
  context-free start-symbols
    Prog

  context-free syntax
    Start                                                             -> Prog                                      {cons("Program")}
    Expression                                                        -> Start                                     {cons("Temp")}
    MethodDeclaration                                                 -> Start                                     {cons("MethodDeclaration")}
    ExecutableCode                                                    -> Start                                     {cons("ExecutableCode")}
    Identifier                                                        -> Reference                                 {cons("ReferenceID")}
    "nil"                                                             -> ConstantReference                         {cons("Null")}
    "false"                                                           -> ConstantReference                         {cons("False")}
    "true"                                                            -> ConstantReference                         {cons("True")}
    "self"                                                            -> PsuedoVariableReference                   {cons("Self")}
    "super"                                                           -> PsuedoVariableReference                   {cons("Super")}
    "thisContext"                                                     -> PsuedoVariableReference                   {cons("This")}
    Identifier                                                        -> BindableIdentifier                        {cons("BindableIdentifier")}
    ConstantReference                                                 -> BindableIdentifier                        {reject}
    PsuedoVariableReference                                           -> BindableIdentifier                        {reject}
    Identifier                                                        -> UnaryMessageSelector                      {cons("UnaryMessageSelector1")}
    Identifier ":"                                                    -> Keyword                                   {cons("Keyword")}
    Keyword+                                                          -> KeywordMessageSelector                    {cons("KeywordMessageSelector1")}
    BinarySelectorChar BinarySelectorChar?                            -> BinaryMessageSelector                     {cons("BinaryMessageSelector1")}
    UnaryMessageSelector                                              -> SymbolInArrayLiteral                      {cons("UnaryMessageSelector2")}
    ConstantReference                                                 -> SymbolInArrayLiteral                      {cons("ConstantReference1"), reject}
    KeywordMessageSelector                                            -> SymbolInArrayLiteral                      {cons("KeywordMessageSelector2")}
    BinaryMessageSelector                                             -> SymbolInArrayLiteral                      {cons("BinaryMessageSelector2")}
    "#" SymbolInArrayLiteral                                          -> SymbolLiteral                             {cons("SymbolInArrayLiteral1")}
    "#" ConstantReference                                             -> SymbolLiteral                             {cons("ConstantReference2")}
    "#" StringLiteral                                                 -> SymbolLiteral                             {cons("StringLiteral1")}
    ObjectArrayLiteral                                                -> ArrayLiteral                              {cons("ObjectArrayLiteral1")}
    ByteArrayLiteral                                                  -> ArrayLiteral                              {cons("ByteArrayLiteral1")}
    "#" NestedObjectArrayLiteral                                      -> ObjectArrayLiteral                        {cons("ObjectArrayLiteral2")}
    "(" LiteralArrayElement* ")"                                      -> NestedObjectArrayLiteral                  {cons("NestedObjectArrayLiteral1")}
    Literal                                                           -> LiteralArrayElement                       {cons("Literal1")}
    BlockLiteral                                                      -> LiteralArrayElement                       {cons("BlockLiteral"), reject}
    NestedObjectArrayLiteral                                          -> LiteralArrayElement                       {cons("NestedObjectArrayLiteral2")}
    SymbolInArrayLiteral                                              -> LiteralArrayElement                       {cons("SymbolInArrayLiteral2")}
    ConstantReference                                                 -> LiteralArrayElement                       {cons("ConstantReference3")}
    "#[" UnsignedIntegerLiteral* "]"                                  -> ByteArrayLiteral                          {cons("ByteArrayLiteral2")}
    BindableIdentifier                                                -> FormalBlockArgumentDeclaration            {cons("FormalBlockArgumentDeclaration")}
    FormalBlockArgumentDeclaration+                                   -> FormalBlockArgumentDeclarationList        {cons("FormalBlockArgumentDeclarationList")}
    FormalBlockArgumentDeclarationList "|"                            -> FormalBlockArgumentDeclarationListWithSep 
    "[" FormalBlockArgumentDeclarationListWithSep? ExecutableCode "]" -> BlockLiteral                              {cons("BlockLiteral1")}
    ConstantReference                                                 -> Literal                                   {cons("ConstantReference4")}
    IntegerLiteral                                                    -> Literal                                   {cons("IntegerLiteral")}
    ScaledDecimalLiteral                                              -> Literal                                   {cons("ScaledDecimalLiteral")}
    FloatingPointLiteral                                              -> Literal                                   {cons("FloatingPointLiteral")}
    CharacterLiteral                                                  -> Literal                                   {cons("CharacterLiteral")}
    StringLiteral                                                     -> Literal                                   {cons("StringLiteral2")}
    SymbolLiteral                                                     -> Literal                                   {cons("SymbolLiteral")}
    ArrayLiteral                                                      -> Literal                                   {cons("ArrayLiteral")}
    BlockLiteral                                                      -> Literal                                   {cons("BlockLiteral2")}
    "(" Statement ")"                                                 -> NestedExpression                          {cons("NestedExpression1")}
    Literal                                                           -> Operand                                   {cons("Literal2")}
    Reference                                                         -> Operand                                   {cons("Reference")}
    NestedExpression                                                  -> Operand                                   {cons("NestedExpression2")}
    UnaryMessageSelector                                              -> UnaryMessage                              {cons("UnaryMessage")}
    UnaryMessage*                                                     -> UnaryMessageChain                         {cons("UnaryMessageChain")}
    Operand UnaryMessageChain                                         -> BinaryMessageOperand                      {cons("BinaryMessageOperand")}
    BinaryMessageSelector BinaryMessageOperand                        -> BinaryMessage                             {cons("BinaryMessage1")}
    BinaryMessage*                                                    -> BinaryMessageChain                        {cons("BinaryMessageChain")}
    BinaryMessageOperand BinaryMessageChain                           -> KeywordMessageArgument                    {cons("KeywordMessageArgument")}
    Keyword KeywordMessageArgument                                    -> KeywordMessageSegment                     {cons("KeywordMessageSegment")}
    KeywordMessageSegment KeywordMessageSegment*                      -> KeywordMessage                            {cons("KeywordMessage")}
    KeywordMessage                                                    -> MessageChain                              {cons("KeywordMessage")}
    BinaryMessage BinaryMessageChain KeywordMessage?                  -> MessageChain                              {cons("BinaryMessage2")}
    UnaryMessage UnaryMessageChain BinaryMessageChain KeywordMessage? -> MessageChain                              {cons("UnaryMessage")}
    ";" MessageChain                                                  -> CascadedMessage                           {cons("CascadedMessage")}
    Operand ExpressionRest?                                           -> Expression                                {cons("Expression")}
    MessageChain CascadedMessage*                                     -> ExpressionRest                            {cons("ExpressionRest")}
    BindableIdentifier ":="                                           -> AssignmentOperation                       {cons("AssignmentOperation")}
    AssignmentOperation* Expression                                   -> Statement                                 {cons("Statement")}
    "^"                                                               -> MethodReturnOperator                      {cons("MethodReturnOperator")}
    MethodReturnOperator? "," Statement                               -> FinalStatement                            {cons("FinalStatement")}
    "|" BindableIdentifier* "|"                                       -> LocalVariableDeclarationList              {cons("LocalVariableDeclarationList")}
    LocalVariableDeclarationList? ExecutableCodeRest?                 -> ExecutableCode                            {cons("ExecutableCode")}
    DottedStatement* FinalStatement Dot?                              -> ExecutableCodeRest                        {cons("ExecutableCodeRest")}
    Statement "."                                                     -> DottedStatement                           {cons("DottedStatement")}
    "."                                                               -> Dot                                       {cons("Dot")}
    UnaryMessageSelector                                              -> UnaryMethodHeader                         {cons("UnaryMethodHeader1")}
    BinaryMessageSelector BindableIdentifier                          -> BinaryMethodHeader                        {cons("BinaryMethodHeader")}
    Keyword BindableIdentifier                                        -> KeywordMethodHeaderSegment                {cons("KeywordMethodHeaderSegment")}
    KeywordMethodHeaderSegment+                                       -> KeywordMethodHeader                       {cons("KeywordMethodHeader1")}
    UnaryMethodHeader                                                 -> MethodHeader                              {cons("UnaryMethodHeader2")}
    BinaryMethodHeader                                                -> MethodHeader                              {cons("BinaryMethodHeader")}
    KeywordMethodHeader                                               -> MethodHeader                              {cons("KeywordMethodHeader2")}
    MethodHeader ExecutableCode                                       -> MethodDeclaration                         {cons("MethodDeclaration")}

  lexical syntax
    

  context-free syntax
    "$Prog"                                      -> Prog                                      {cons("Prog-Plhdr"), placeholder}
    "$Start"                                     -> Start                                     {cons("Start-Plhdr"), placeholder}
    "$PsuedoVariableReference"                   -> PsuedoVariableReference                   {cons("PsuedoVariableReference-Plhdr"), placeholder}
    "$Identifier"                                -> Identifier                                {cons("Identifier-Plhdr"), placeholder}
    "$BinarySelectorChar"                        -> BinarySelectorChar                        {cons("BinarySelectorChar-Plhdr"), placeholder}
    "$KeywordMessageSelector"                    -> KeywordMessageSelector                    {cons("KeywordMessageSelector-Plhdr"), placeholder}
    "$ObjectArrayLiteral"                        -> ObjectArrayLiteral                        {cons("ObjectArrayLiteral-Plhdr"), placeholder}
    "$NestedObjectArrayLiteral"                  -> NestedObjectArrayLiteral                  {cons("NestedObjectArrayLiteral-Plhdr"), placeholder}
    "$SymbolInArrayLiteral"                      -> SymbolInArrayLiteral                      {cons("SymbolInArrayLiteral-Plhdr"), placeholder}
    "$LiteralArrayElement"                       -> LiteralArrayElement                       {cons("LiteralArrayElement-Plhdr"), placeholder}
    "$ByteArrayLiteral"                          -> ByteArrayLiteral                          {cons("ByteArrayLiteral-Plhdr"), placeholder}
    "$UnsignedIntegerLiteral"                    -> UnsignedIntegerLiteral                    {cons("UnsignedIntegerLiteral-Plhdr"), placeholder}
    "$FormalBlockArgumentDeclaration"            -> FormalBlockArgumentDeclaration            {cons("FormalBlockArgumentDeclaration-Plhdr"), placeholder}
    "$FormalBlockArgumentDeclarationList"        -> FormalBlockArgumentDeclarationList        {cons("FormalBlockArgumentDeclarationList-Plhdr"), placeholder}
    "$FormalBlockArgumentDeclarationListWithSep" -> FormalBlockArgumentDeclarationListWithSep {cons("FormalBlockArgumentDeclarationListWithSep-Plhdr"), placeholder}
    "$ConstantReference"                         -> ConstantReference                         {cons("ConstantReference-Plhdr"), placeholder}
    "$IntegerLiteral"                            -> IntegerLiteral                            {cons("IntegerLiteral-Plhdr"), placeholder}
    "$ScaledDecimalLiteral"                      -> ScaledDecimalLiteral                      {cons("ScaledDecimalLiteral-Plhdr"), placeholder}
    "$FloatingPointLiteral"                      -> FloatingPointLiteral                      {cons("FloatingPointLiteral-Plhdr"), placeholder}
    "$CharacterLiteral"                          -> CharacterLiteral                          {cons("CharacterLiteral-Plhdr"), placeholder}
    "$StringLiteral"                             -> StringLiteral                             {cons("StringLiteral-Plhdr"), placeholder}
    "$SymbolLiteral"                             -> SymbolLiteral                             {cons("SymbolLiteral-Plhdr"), placeholder}
    "$ArrayLiteral"                              -> ArrayLiteral                              {cons("ArrayLiteral-Plhdr"), placeholder}
    "$BlockLiteral"                              -> BlockLiteral                              {cons("BlockLiteral-Plhdr"), placeholder}
    "$Literal"                                   -> Literal                                   {cons("Literal-Plhdr"), placeholder}
    "$Reference"                                 -> Reference                                 {cons("Reference-Plhdr"), placeholder}
    "$NestedExpression"                          -> NestedExpression                          {cons("NestedExpression-Plhdr"), placeholder}
    "$BinaryMessageOperand"                      -> BinaryMessageOperand                      {cons("BinaryMessageOperand-Plhdr"), placeholder}
    "$KeywordMessageArgument"                    -> KeywordMessageArgument                    {cons("KeywordMessageArgument-Plhdr"), placeholder}
    "$KeywordMessageSegment"                     -> KeywordMessageSegment                     {cons("KeywordMessageSegment-Plhdr"), placeholder}
    "$BinaryMessage"                             -> BinaryMessage                             {cons("BinaryMessage-Plhdr"), placeholder}
    "$UnaryMessage"                              -> UnaryMessage                              {cons("UnaryMessage-Plhdr"), placeholder}
    "$UnaryMessageChain"                         -> UnaryMessageChain                         {cons("UnaryMessageChain-Plhdr"), placeholder}
    "$BinaryMessageChain"                        -> BinaryMessageChain                        {cons("BinaryMessageChain-Plhdr"), placeholder}
    "$KeywordMessage"                            -> KeywordMessage                            {cons("KeywordMessage-Plhdr"), placeholder}
    "$Operand"                                   -> Operand                                   {cons("Operand-Plhdr"), placeholder}
    "$ExpressionRest"                            -> ExpressionRest                            {cons("ExpressionRest-Plhdr"), placeholder}
    "$MessageChain"                              -> MessageChain                              {cons("MessageChain-Plhdr"), placeholder}
    "$CascadedMessage"                           -> CascadedMessage                           {cons("CascadedMessage-Plhdr"), placeholder}
    "$AssignmentOperation"                       -> AssignmentOperation                       {cons("AssignmentOperation-Plhdr"), placeholder}
    "$Expression"                                -> Expression                                {cons("Expression-Plhdr"), placeholder}
    "$MethodReturnOperator"                      -> MethodReturnOperator                      {cons("MethodReturnOperator-Plhdr"), placeholder}
    "$LocalVariableDeclarationList"              -> LocalVariableDeclarationList              {cons("LocalVariableDeclarationList-Plhdr"), placeholder}
    "$ExecutableCodeRest"                        -> ExecutableCodeRest                        {cons("ExecutableCodeRest-Plhdr"), placeholder}
    "$FinalStatement"                            -> FinalStatement                            {cons("FinalStatement-Plhdr"), placeholder}
    "$DottedStatement"                           -> DottedStatement                           {cons("DottedStatement-Plhdr"), placeholder}
    "$Statement"                                 -> Statement                                 {cons("Statement-Plhdr"), placeholder}
    "$Dot"                                       -> Dot                                       {cons("Dot-Plhdr"), placeholder}
    "$UnaryMessageSelector"                      -> UnaryMessageSelector                      {cons("UnaryMessageSelector-Plhdr"), placeholder}
    "$BinaryMessageSelector"                     -> BinaryMessageSelector                     {cons("BinaryMessageSelector-Plhdr"), placeholder}
    "$Keyword"                                   -> Keyword                                   {cons("Keyword-Plhdr"), placeholder}
    "$BindableIdentifier"                        -> BindableIdentifier                        {cons("BindableIdentifier-Plhdr"), placeholder}
    "$KeywordMethodHeaderSegment"                -> KeywordMethodHeaderSegment                {cons("KeywordMethodHeaderSegment-Plhdr"), placeholder}
    "$UnaryMethodHeader"                         -> UnaryMethodHeader                         {cons("UnaryMethodHeader-Plhdr"), placeholder}
    "$BinaryMethodHeader"                        -> BinaryMethodHeader                        {cons("BinaryMethodHeader-Plhdr"), placeholder}
    "$KeywordMethodHeader"                       -> KeywordMethodHeader                       {cons("KeywordMethodHeader-Plhdr"), placeholder}
    "$MethodDeclaration"                         -> MethodDeclaration                         {cons("MethodDeclaration-Plhdr"), placeholder}
    "$MethodHeader"                              -> MethodHeader                              {cons("MethodHeader-Plhdr"), placeholder}
    "$ExecutableCode"                            -> ExecutableCode                            {cons("ExecutableCode-Plhdr"), placeholder}

module completion/Smalltalk-completion-insertions
imports Smalltalk

imports completion/Base-completion-insertions

exports
  context-free start-symbols
    Prog Start PsuedoVariableReference Identifier BinarySelectorChar
    KeywordMessageSelector ObjectArrayLiteral NestedObjectArrayLiteral
    SymbolInArrayLiteral LiteralArrayElement ByteArrayLiteral
    UnsignedIntegerLiteral FormalBlockArgumentDeclaration
    FormalBlockArgumentDeclarationList FormalBlockArgumentDeclarationListWithSep
    ConstantReference IntegerLiteral ScaledDecimalLiteral FloatingPointLiteral
    CharacterLiteral StringLiteral SymbolLiteral ArrayLiteral BlockLiteral
    Literal Reference NestedExpression BinaryMessageOperand
    KeywordMessageArgument KeywordMessageSegment BinaryMessage UnaryMessage
    UnaryMessageChain BinaryMessageChain KeywordMessage Operand ExpressionRest
    MessageChain CascadedMessage AssignmentOperation Expression
    MethodReturnOperator LocalVariableDeclarationList ExecutableCodeRest
    FinalStatement DottedStatement Statement Dot UnaryMessageSelector
    BinaryMessageSelector Keyword BindableIdentifier KeywordMethodHeaderSegment
    UnaryMethodHeader BinaryMethodHeader KeywordMethodHeader MethodDeclaration
    MethodHeader ExecutableCode

  context-free syntax
    COMPLETION-INSERTION -> Prog                                      {cons("Prog-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Start                                     {cons("Start-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> PsuedoVariableReference                   {cons("PsuedoVariableReference-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Identifier                                {cons("Identifier-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> BinarySelectorChar                        {cons("BinarySelectorChar-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> KeywordMessageSelector                    {cons("KeywordMessageSelector-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> ObjectArrayLiteral                        {cons("ObjectArrayLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> NestedObjectArrayLiteral                  {cons("NestedObjectArrayLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> SymbolInArrayLiteral                      {cons("SymbolInArrayLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> LiteralArrayElement                       {cons("LiteralArrayElement-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> ByteArrayLiteral                          {cons("ByteArrayLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> UnsignedIntegerLiteral                    {cons("UnsignedIntegerLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> FormalBlockArgumentDeclaration            {cons("FormalBlockArgumentDeclaration-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> FormalBlockArgumentDeclarationList        {cons("FormalBlockArgumentDeclarationList-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> FormalBlockArgumentDeclarationListWithSep {cons("FormalBlockArgumentDeclarationListWithSep-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> ConstantReference                         {cons("ConstantReference-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> IntegerLiteral                            {cons("IntegerLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> ScaledDecimalLiteral                      {cons("ScaledDecimalLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> FloatingPointLiteral                      {cons("FloatingPointLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> CharacterLiteral                          {cons("CharacterLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> StringLiteral                             {cons("StringLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> SymbolLiteral                             {cons("SymbolLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> ArrayLiteral                              {cons("ArrayLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> BlockLiteral                              {cons("BlockLiteral-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Literal                                   {cons("Literal-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Reference                                 {cons("Reference-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> NestedExpression                          {cons("NestedExpression-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> BinaryMessageOperand                      {cons("BinaryMessageOperand-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> KeywordMessageArgument                    {cons("KeywordMessageArgument-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> KeywordMessageSegment                     {cons("KeywordMessageSegment-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> BinaryMessage                             {cons("BinaryMessage-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> UnaryMessage                              {cons("UnaryMessage-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> UnaryMessageChain                         {cons("UnaryMessageChain-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> BinaryMessageChain                        {cons("BinaryMessageChain-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> KeywordMessage                            {cons("KeywordMessage-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Operand                                   {cons("Operand-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> ExpressionRest                            {cons("ExpressionRest-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> MessageChain                              {cons("MessageChain-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> CascadedMessage                           {cons("CascadedMessage-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> AssignmentOperation                       {cons("AssignmentOperation-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Expression                                {cons("Expression-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> MethodReturnOperator                      {cons("MethodReturnOperator-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> LocalVariableDeclarationList              {cons("LocalVariableDeclarationList-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> ExecutableCodeRest                        {cons("ExecutableCodeRest-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> FinalStatement                            {cons("FinalStatement-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> DottedStatement                           {cons("DottedStatement-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Statement                                 {cons("Statement-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Dot                                       {cons("Dot-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> UnaryMessageSelector                      {cons("UnaryMessageSelector-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> BinaryMessageSelector                     {cons("BinaryMessageSelector-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> Keyword                                   {cons("Keyword-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> BindableIdentifier                        {cons("BindableIdentifier-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> KeywordMethodHeaderSegment                {cons("KeywordMethodHeaderSegment-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> UnaryMethodHeader                         {cons("UnaryMethodHeader-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> BinaryMethodHeader                        {cons("BinaryMethodHeader-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> KeywordMethodHeader                       {cons("KeywordMethodHeader-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> MethodDeclaration                         {cons("MethodDeclaration-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> MethodHeader                              {cons("MethodHeader-Plhdr"), placeholder-insertion}
    COMPLETION-INSERTION -> ExecutableCode                            {cons("ExecutableCode-Plhdr"), placeholder-insertion}

  lexical syntax
    COMPLETION-INSERTION -> "nil"         {literal-completion}
    COMPLETION-INSERTION -> "false"       {literal-completion}
    COMPLETION-INSERTION -> "true"        {literal-completion}
    COMPLETION-INSERTION -> "self"        {literal-completion}
    COMPLETION-INSERTION -> "super"       {literal-completion}
    COMPLETION-INSERTION -> "thisContext" {literal-completion}
    COMPLETION-INSERTION -> ":"           {literal-completion}
    COMPLETION-INSERTION -> "#"           {literal-completion}
    COMPLETION-INSERTION -> "#["          {literal-completion}
    COMPLETION-INSERTION -> "["           {literal-completion}
    COMPLETION-INSERTION -> "]"           {literal-completion}
    COMPLETION-INSERTION -> "("           {literal-completion}
    COMPLETION-INSERTION -> ")"           {literal-completion}
    COMPLETION-INSERTION -> ";"           {literal-completion}
    COMPLETION-INSERTION -> ":="          {literal-completion}
    COMPLETION-INSERTION -> "^"           {literal-completion}
    COMPLETION-INSERTION -> ","           {literal-completion}
    COMPLETION-INSERTION -> "|"           {literal-completion}
    COMPLETION-INSERTION -> "."           {literal-completion}

exports
  lexical syntax
     -> COMPLETION-INSERTION 