module Smalltalk

imports
  
	Base

context-free start-symbols
  
	Prog

context-free syntax
  
  	Prog.Program = Start
  	Start.Temp = Expression
	Start.MethodDeclaration = MethodDeclaration
//	Start.ExecutableCode = ExecutableCodeRest
//	Start.Start = Expression
	Start.Empty = <>
	
	Reference.ReferenceID = Identifier
	
	ConstantReference.Null = <nil>
	ConstantReference.False = <false>
	ConstantReference.True = <true>
	
	PsuedoVariableReference.Self = <self>
	PsuedoVariableReference.Super = <super>
	PsuedoVariableReference.This = <thisContext>
	
	BindableIdentifier.BindableIdentifier = Identifier
	BindableIdentifier = ConstantReference {reject}
	BindableIdentifier = PsuedoVariableReference {reject}
	
	UnaryMessageSelector.UnaryMessageSelector1 = Identifier  //duplicate constructor, can combine?
	Keyword.Keyword = <<Identifier> :>
	KeywordMessageSelector.KeywordMessageSelector1 = Keyword+  //duplicate, can combine?
	BinaryMessageSelector.UnarySelector = <<BinarySelectorChar>>
	BinaryMessageSelector.BinarySelector = <<BinarySelectorChar> <BinarySelectorChar>>  //duplicate, can combine?
	
	
	SymbolInArrayLiteral.UnaryMessageSelector2 = UnaryMessageSelector
	SymbolInArrayLiteral.ConstantReference1 = ConstantReference {reject} //duplicate, can combine?
	SymbolInArrayLiteral.KeywordMessageSelector2 = KeywordMessageSelector
	SymbolInArrayLiteral.BinaryMessageSelector2 = BinaryMessageSelector
	
	SymbolLiteral.SymbolInArrayLiteral1 = <# <SymbolInArrayLiteral>>  //duplicate, can combine?
	SymbolLiteral.ConstantReference2 = <# <ConstantReference>> 
	SymbolLiteral.StringLiteral1 = <# <StringLiteral>> //duplicate constructor
	ArrayLiteral.ObjectArrayLiteral1 = ObjectArrayLiteral //duplicate
	ArrayLiteral.ByteArrayLiteral1 = ByteArrayLiteral //duplicate
	ObjectArrayLiteral.ObjectArrayLiteral2 = <# <NestedObjectArrayLiteral>>
	NestedObjectArrayLiteral.NestedObjectArrayLiteral1 = <( <LiteralArrayElement*> )> //duplicate
	LiteralArrayElement.Literal1 = Literal //duplicate
	LiteralArrayElement.BlockLiteral = BlockLiteral {reject}
	LiteralArrayElement.NestedObjectArrayLiteral2 = NestedObjectArrayLiteral
	LiteralArrayElement.SymbolInArrayLiteral2 = SymbolInArrayLiteral
	LiteralArrayElement.ConstantReference3 = ConstantReference
	ByteArrayLiteral.ByteArrayLiteral2 = <#[ <{UnsignedIntegerLiteral ""}*> ]>
	
	FormalBlockArgumentDeclaration.FormalBlockArgumentDeclaration = <: <BindableIdentifier>>
	FormalBlockArgumentDeclarationList.FormalBlockArgumentDeclarationList = FormalBlockArgumentDeclaration+
	FormalBlockArgumentDeclarationListWithSep = <<FormalBlockArgumentDeclarationList> |>
	BlockLiteral.BlockLiteral1 = <[ <FormalBlockArgumentDeclarationListWithSep?> <ExecutableCode> ]> //duplicate
	
	Literal.ConstantReference4 = ConstantReference
	Literal.IntegerLiteral  = IntegerLiteral 
	Literal.ScaledDecimalLiteral = ScaledDecimalLiteral 
	Literal.FloatingPointLiteral = FloatingPointLiteral 
	Literal.CharacterLiteral = CharacterLiteral 
	Literal.StringLiteral2 = StringLiteral 
	Literal.SymbolLiteral = SymbolLiteral 
	Literal.ArrayLiteral = ArrayLiteral 
	Literal.BlockLiteral2 = BlockLiteral
	
	
	Operand.Literal2 = Literal
	Operand.Reference = Reference
	Operand.NestedExpression = <( <Statement> )>
	
	UnaryMessage.UnaryMessage = UnaryMessageSelector
	UnaryMessageChain.UnaryMessageChain = UnaryMessage*
	
	BinaryMessageOperand.BinaryMessageOperand = <<Operand> <UnaryMessageChain>>
	BinaryMessage.BinaryMessage1 = <<BinaryMessageSelector> <BinaryMessageOperand>> //duplicate
	BinaryMessageChain.BinaryMessageChain = BinaryMessage*
	
	KeywordMessageArgument.KeywordMessageArgument = <<BinaryMessageOperand> <BinaryMessageChain>>
	KeywordMessageSegment.KeywordMessageSegment = <<Keyword> <KeywordMessageArgument>>
	KeywordMessage.KeywordMessage = <<KeywordMessageSegment> <KeywordMessageSegment*>>
	
	MessageChain.KeywordMessage = KeywordMessage
	MessageChain.BinaryMessage2 = <<BinaryMessage> <BinaryMessageChain>>
	MessageChain.KeywordMessage = <<BinaryMessage> <BinaryMessageChain> <KeywordMessage>>
	MessageChain.UnaryMessage = <<UnaryMessage> <UnaryMessageChain> <BinaryMessageChain> <KeywordMessage?>>
	
	CascadedMessage.CascadedMessage = <; <MessageChain>>
	
	Expression.SingletonExpression = Operand
	Expression.Expression = <<Operand> <MessageChain> <CascadedMessage*>>
	
	AssignmentOperation.AssignmentOperation = <<BindableIdentifier> :=>
	Statement.Statement = <<AssignmentOperation*> <Expression>>
	MethodReturnOperator.MethodReturnOperator = <^>
	FinalStatement.FinalStatement = <<MethodReturnOperator?> <Statement>>
	
	LocalVariableDeclarationList.LocalVariableDeclarationList = <| <BindableIdentifier*> |>
	ExecutableCode.ExecutableCode = <<LocalVariableDeclarationList?> <ExecutableCodeRest?>>
	ExecutableCodeRest.ExecutableCodeRest = <<DottedStatement*> <FinalStatement> <Dot?>>
	DottedStatement.DottedStatement = <<Statement> .>
	Dot.Dot = <.>
	
	UnaryMethodHeader.UnaryMethodHeader1 = UnaryMessageSelector //duplicate
	BinaryMethodHeader.BinaryMethodHeader = <<BinaryMessageSelector> <BindableIdentifier>>
	KeywordMethodHeaderSegment.KeywordMethodHeaderSegment = <<Keyword> <BindableIdentifier>>
	KeywordMethodHeader.KeywordMethodHeader1 = KeywordMethodHeaderSegment+ //duplicate
	MethodHeader.UnaryMethodHeader2 = UnaryMethodHeader 
	MethodHeader.BinaryMethodHeader = BinaryMethodHeader 
	MethodHeader.KeywordMethodHeader2 = KeywordMethodHeader 
	MethodDeclaration.MethodDeclaration = <<MethodHeader> <ExecutableCode>>
	
context-free priorities
	


